---
title: "JWT認証を仕組みから実装まで理解する"
emoji: "🛡️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [JWT, 認証, セキュリティ]
published: false
---

## はじめに

プログラミングスクールRUNTEQでWebエンジニア兼講師をしているいっぺい（[@ippei_111](https://x.com/ippei_111)）と申します。

いきなりですが、Web開発をしている中で「JWT認証って何となく使用しているけど、実際の仕組みはあまり理解できていない」「セッション認証とJWT認証の使い分けがわからない」などと感じたことはありませんか？

私自身、JWT認証についての理解が浅いと感じていたため、本記事では、JWT認証の基本的な仕組みから実装方法、セキュリティ面まで、体系的にまとめてみようと思います。

:::message
JWT認証はセキュリティに関わる重要な技術のため、間違った実装をすると深刻な脆弱性につながる可能性があります。
本記事では実装例も紹介しますが、実際のプロダクションで使用する際は、さらなるセキュリティ検証を行うことを強く推奨します。
また、間違っている説明や解釈などありましたら、ご指摘いただけると幸いです。
:::

## 1. JWT認証の基礎

まず、JWT認証の基本的な概念と、それがどのような背景から登場したのかを解説します。

### 1.1 JWTの登場背景と従来の認証方式の課題

従来のWebアプリケーションでは、「セッション・Cookie認証」が認証方式の主流でした。これは、サーバー側でユーザーの認証状態をセッションとして管理する方式です。

**セッション・Cookie認証の基本的な流れ**
1.  ユーザーがログインすると、サーバーはセッションIDを発行します。
2.  サーバーは、そのセッションIDとユーザー情報を紐付けて自身のストレージ（セッションストレージ）に保存します。
3.  クライアント（ブラウザ）は受け取ったセッションIDをCookieに保存し、以降のリクエストで常にそのCookieを送信します。
4.  サーバーは受け取ったセッションIDを元に、ストレージからユーザー情報を参照して認証状態を確認します。

この方法は長年広く使われてきましたが、アプリケーションの構成が複雑化するにつれて、いくつかの課題が顕在化しました。

![](/images/jwt-issue.png)

* **スケーラビリティ**: 負荷分散のためにサーバーを複数台構成にする場合、全サーバーでセッション情報を共有するための仕組み（スティッキーセッションや共有ストレージなど）が別途必要になり、構成が複雑化します。
* **クロスドメイン/クロスプラットフォーム**: Cookieのドメイン制約により、異なるドメインを持つサービス間での認証情報の共有が困難です。また、Cookieの仕組みを持たないネイティブアプリなど、Webブラウザ以外のクライアントとの相性も課題でした。
* **マイクロサービスアーキテクチャとの親和性**: サービスが機能ごとに分割されている場合、サービス間で認証状態を連携させるための仕組みが複雑になりがちです。

これらの課題を解決するアプローチとして登場したのが、**ステートレス**な認証を実現するJWT（JSON Web Token）です。

### 1.2 JWT（JSON Web Token）とは

JWTとは、情報を安全にやり取りするための国際的なルール（RFC 7519）として標準化された仕様の一つです。その実体は、`.`（ピリオド）で区切られた、URLセーフな文字列です。

**RFC 7519とは**
RFC 7519は、JWTの仕様を定義した文書で、JSON Web Tokenの構造や使用方法を規定しています。
https://tex2e.github.io/rfc-translater/html/rfc7519.html

JWTの例）
```bash
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

このJWTは、以下の3つのパートから構成されています。
1.  **ヘッダー (Header)**: トークンの種別（`typ`）と、署名アルゴリズム（`alg`）を定義するパートです。
2.  **ペイロード (Payload)**: ユーザーIDや権限、有効期限など、伝達したい情報（クレーム）を含むパートです。
3.  **署名 (Signature)**: ヘッダーとペイロードが改ざんされていないことを保証するためのデジタル署名です。

![](/images/jwt-kouzou.png)

この構造により、JWTは以下のような特徴を持ちます。

* **自己完結型 (Self-contained)**: トークン自体が認証に必要な情報を持っているため、サーバーは状態を保持するためのストレージにアクセスする必要がありません。
* **ステートレス (Stateless)**: サーバー側で認証状態を管理しないため、リクエストをどのサーバーで処理してもよく、スケーラビリティを確保しやすくなります。
* **改ざん耐性**: デジタル署名によって、トークンの内容が途中で書き換えられていないかを検証できます。

### 1.3 認証方式の比較：セッション認証とJWT認証

ここで、2つの認証方式の主な違いを整理します。最も本質的な違いは、**認証状態をどこで管理するか（ステートフルかステートレスか）** という点です。

* **セッション・Cookie認証**: サーバー側で状態を管理する**ステートフル**な方式。
* **JWT認証**: トークン自体が情報を持ち、サーバーは状態を持たない**ステートレス**な方式。

この違いが、それぞれの特性に影響を与えます。

![](/images/jwt-cookie-jwt.png)

| 項目       | セッション・Cookie認証 | JWT認証      |
|----------|----------------|------------|
| 状態管理     | ステートフル（サーバーが状態を保持）         | ステートレス（サーバーは状態を持たない）     |
| サーバー負荷   | セッションストレージへのアクセスが必要  | 署名の暗号計算のみで済む    |
| 拡張性       | サーバー増設時にセッション共有の考慮が必要  | サーバーを増やしやすい（水平スケールが容易） |
| トークンサイズ  | 小さい（セッションIDのみ） | 大きい（情報を含む） |
| 強制無効化   | サーバー側でセッションを破棄すればOK（容易）  | 有効期限まで原則有効（工夫が必要） |
| 外部連携  | Cookieの制約により困難な場合がある | トークンを渡すだけで連携可能（容易） |
| モバイル対応   | Cookieの扱いに注意が必要 | ヘッダーでの送受信が基本で相性が良い  |

## 2. JWTの構造を深く知る

JWTが単なる長い文字列ではないことは、理解できたと思います、ここでは、その文字列を構成する「ヘッダー」「ペイロード」「署名」の3つのパートを、さらに詳しく見ていきます。

### 2.1 ヘッダー

ヘッダーは、そのJWTが「どのようなトークンで、どのように署名されているか」を定義するメタデータ部分です。具体的には、以下の2つの情報を含むJSONオブジェクトで構成されるのが一般的です。

- `alg`（Algorithm）: 署名を生成するために使用されるアルゴリズムを指定します。例えば、`HS256`（HMAC SHA-256）や`RS256`（RSA SHA-256）などがあります。
- `typ`（Type）: トークンのタイプを指定します。JWTの場合は通常`JWT`が指定されます。
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
このJSONオブジェクトがBase64URLエンコードされ、JWTの最初の部分（ヘッダー）を形成します。

### 2.2 ペイロード

ペイロードは、トークンを通じて伝えたい情報であり、「クレーム（Claims）」を格納する部分です。クレームとは、ユーザーIDや名前、権限、トークンの有効期限など、情報の断片を指します。
```json
{
  "sub": "user-12345",
  "name": "John Doe",
  "role": "admin",
  "exp": 1720854720
}
```
このペイロードもヘッダーと同様に、Base64URLエンコードされ、JWTの2番目の部分を形成します。

クレームには、用途に応じて3つの種類があります。

1. **登録済みクレーム（Registered Claims）**
仕様としてあらかじめ定義されているクレームです。これらは必須ではありませんが、相互運用性を高めるために使用が推奨されています。

| クレーム | 説明                                    |
|----------|-----------------------------------------|
| `iss`    | (Issuer) 発行者                         |
| `sub`    | (Subject) このJWTの主題（ユーザーIDなど） |
| `aud`    | (Audience) このJWTの受信者              |
| `exp`    | (Expiration Time) 有効期限（Unixタイムスタンプ） |
| `iat`    | (Issued At) 発行日時（Unixタイムスタンプ） |
| `nbf`    | (Not Before) 有効期間の開始日時         |
| `jti`    | (JWT ID) トークンの一意な識別子         |

2. **パブリッククレーム（Public Claims）**
JWTの利用者が自由に定義できるクレームですが、他のシステムと重複しないように、[IANA JSON Web Token Claims Registry](https://www.iana.org/assignments/jwt/jwt.xhtml) で管理されている名前を使用するか、衝突しないURI形式の名前空間を持つ名前を定義する必要があります。

https://www.iana.org/assignments/jwt/jwt.xhtml

3. **プライベートクレーム（Private Claims）**
発行者と受信者の間で合意の上で自由に使用される、アプケーション固有のクレームです。`userId`や`role`など、アプリケーションが必要とする情報をここに格納します。

:::message alert
ペイロードは暗号化されているわけではありません。Base64URLエンコードは、単なるデータの表現形式の変換であり、誰でも簡単にでコードして中身を閲覧することができます。
したがって、ペイロードにはパスワードやクレジットカード番号などの機密情報を絶対に含めないでください。
:::

### 2.3 署名

署名は、JWTの最も重要なセキュリティ機能です。この署名があることで、以下の2点を保証することができます。

- **完全性（Integrity）** : トークンが途中で改ざんされていないこと。
- **認証（Authentication）** : トークンが信頼できる発行者によって作成されたものであること。

署名は、以下の手順で生成されます。

HMACSHA256( Base64URL(ヘッダー) + "." + Base64URL(ペイロード), 秘密鍵 )

つまり、「エンコードされたヘッダー」と「エンコードされたペイロード」を`.`で連結した文字列を、ヘッダーで指定されたアルゴリズムと、サーバーだけが知っている秘密鍵を使って計算したハッシュ値です。

この秘密鍵を知らない第三者は、たとえヘッダーやペイロードを改ざんしても、正しい署名を再生成することができません。サーバーはリクエストを受け取るたびに、同じ方法で署名を計算し直し、送られてきた署名と一致するかを検証することで、トークンの正当性を確認します。

### 2.4 Base64URLエンコーディングとは？

JWTの各パートを構成するBase64URLエンコーディングについて補足します。これは、バイナリデータをテキストデータに変換するBase64を、URLで安全に使用できるように改良したものです。

通常のBase64では、URLにおいて特別な意味を持つ文字（`+`や`-`）や、パディングのための`=`が使われます。Base64URLでは、これらの文字をURLにセーフな文字に置き換え、パディングを削除しています。

このエンコーディングにより、JWTはHTTPヘッダーやURLクエリパラメータとして、問題なく安全に含めることができるのです。

https://qiita.com/kunihiros/items/2722d690b1525813c45e

## 3. JWT認証の動作原理

JWTの構造を理解したところで、次はそのJWTが実際のアプリケーションでどのように機能するのか、その「動作原理」を見ていきます。ユーザーのログインから、認証が必要な情報へのアクセスまで、一連の流れを追うことで、JWT認証の全体像がより明確になります。

### 3.1 認証フローの全体像

JWT認証のフローは、大きく分けて「**①トークン発行**」と「**②トークンを利用したAPIアクセス**」の2つのフェーズで構成されます。

```mermaid
sequenceDiagram
    participant Client as クライアント
    participant AuthServer as 認証サーバー
    participant ApiServer as APIサーバー

    rect rgb(254, 243, 199)
        Note over Client, AuthServer: ① トークン発行フェーズ
        Client->>AuthServer: 1. ログイン要求 (ID/PW)
        activate AuthServer
        Note right of AuthServer: 認証情報を検証し、<br/>OKならJWTを生成・署名
        AuthServer-->>Client: 2. JWTを返却
        deactivate AuthServer
    end

    rect rgb(236, 253, 245)
        Note over Client, ApiServer: ② APIアクセスフェーズ
        Client->>ApiServer: 3. APIリクエスト (JWTをヘッダーに付与)
        activate ApiServer
        Note left of ApiServer: 4. JWTの署名・有効期限を検証
        ApiServer-->>Client: 5. 検証OKならデータを返却
        deactivate ApiServer
    end
```

1. ログインとトークン発行
  - **クライアント→サーバー** : ユーザーがIDとパスワードを入力し、ログインをリクエストします。
  - **サーバー** : 受け取った認証情報を検証します。正しければ、ユーザー情報を含むペイロードと署名を持つJWTを生成します。
  - **サーバー→クライアント** : 生成したJWTをクライアントに渡します。クライアントは、このJWTを安全な場所に保存します。（例：ローカルストレージやセッションストレージ）
2. 保護されたリソースへのアクセス
  - **クライアント→サーバー** : 認証が必要なAPIリクエストを送る際、HTTPの`Authorization`ヘッダーに、保存しておいたJWTを`Bearer`スキームとともに含めます。
  - **サーバー** : リクエストを受け取ると、まず`Authorization`ヘッダーからJWTを取り出します。
  - **サーバー** : 取り出したJWTの署名を検証し、改ざんがないか、そして信頼できる発行元からのものかを確認します。同時に、ペイロード内の有効期限（`exp`）が切れていないかもチェックします。
  - **サーバー→クライアント** : 検証がすべて成功すれば、リクエストされた処理を実行し、結果をクライアントに返します。検証に失敗した場合は、`401 Unauthorized`エラーを返します。

### 3.2 トークンの生成プロセス

サーバーはユーザーの認証に成功した後に、どのようにしてJWTを生成するのか、そのプロセスを詳しく見ていきます。

```mermaid
sequenceDiagram
    participant Client as クライアント
    participant AuthServer as 認証サーバー

    rect rgb(254, 243, 199)
        Note over AuthServer: JWT生成プロセス
        AuthServer->>AuthServer: 1. ヘッダー(JSON: alg, typ)を準備
        AuthServer->>AuthServer: 2. ペイロード(JSON: sub, exp, 他のクレーム)を準備
        AuthServer->>AuthServer: 3. ヘッダーとペイロードをBase64URLエンコード
        AuthServer->>AuthServer: 4. エンコード済みヘッダー + "." + エンコード済みペイロード を連結
        AuthServer->>AuthServer: 5. 連結文字列を秘密鍵で署名 (HMACSHA256 等)
        AuthServer->>AuthServer: 6. エンコード済みヘッダー . エンコード済みペイロード . 署名 を連結しJWT完成
    end

    rect rgb(236, 253, 245)
        Note over AuthServer, Client: トークン返却
        AuthServer-->>Client: 7. 生成したJWTを返却
    end
```

1. **ヘッダーの準備** : `alg`と`typ`を含むJSONオブジェクトを用意します。
2. **ペイロードの準備** : ユーザーID（`sub`）や有効期限（`exp`）など、必要なクレームを含むJSONオブジェクトを用意します。
3. **エンコード** : ヘッダーとペイロードを、それぞれBase64URLエンコードします。
4. **署名対象の作成** : エンコードされたヘッダーとペイロードを、`.`で連結します。
5. **署名の生成** : 4で作成した文字列を、秘密鍵を使って署名アルゴリズムでハッシュ化し、署名を生成します。
6. **JWTの完成** : 「エンコード済みヘッダー」「エンコード済みペイロード」「署名」を3つの`.`で連結して、最終的なJWTを作成します。

:::details Node.jsでの実装例 (jsonwebtokenライブラリを使用)
```javascript
const jwt = require('jsonwebtoken');

/**
 * ユーザー情報に基づいてJWTを生成する関数
 * @param {object} user - ユーザー情報 (id, email, roleなど)
 * @returns {string} 生成されたJWT
 */
function generateToken(user) {
  // ペイロードに含める情報を定義
  const payload = {
    sub: user.id,
    email: user.email,
    role: user.role,
  };

  // 秘密鍵（環境変数から取得するのが望ましい）
  const secretKey = process.env.JWT_SECRET || 'your-very-secret-key';

  // オプションでアルゴリズムや有効期限を指定
  const options = {
    expiresIn: '1h', // 有効期限: 1時間
    algorithm: 'HS256' // 署名アルゴリズム
  };

  // jwt.sign()でトークンを生成
  const token = jwt.sign(payload, secretKey, options);

  return token;
}

// --- 使用例 ---
const sampleUser = { id: 'user-12345', email: 'user@example.com', role: 'user' };
const token = generateToken(sampleUser);
console.log(token);
```
:::

### 3.3 トークンの検証プロセス

クライアントからJWTを受け取ったサーバーは、その正当性を厳格に検証する必要があります。この検証プロセスこそが、JWT認証のセキュリティを担保する重要なステップになります。

```mermaid
sequenceDiagram
    participant Client as クライアント
    participant ApiServer as APIサーバー

    rect rgb(236, 253, 245)
        Note over ApiServer: JWT検証プロセス
        Client->>ApiServer: 1. AuthorizationヘッダーでJWT受信
        ApiServer->>ApiServer: 2. JWTを「ヘッダー」「ペイロード」「署名」に分割
        ApiServer->>ApiServer: 3. 署名検証 (ヘッダー＋ペイロード, 秘密鍵)
        ApiServer->>ApiServer: 4. `exp`/`nbf`/`aud`/`iss`などのクレーム検証
        alt 検証OK
            ApiServer-->>Client: 5. リクエスト処理を実行・200 OK返却
        else 検証NG
            ApiServer-->>Client: 6. 401 Unauthorized返却
        end
    end

```

1. **トークンの受信と分割** : `Authorization: Bearer <JWT>`ヘッダーからトークンを抽出し、`.`を基準にヘッダー、ペイロード、署名の3つのパートに分割します。
2. **署名の検証**
  - 受信したヘッダーとペイロード（エンコード済みの状態）を`.`で連結します。
  - サーバーが保持している秘密鍵を使い、ヘッダーで指定されたアルゴリズムで署名を再計算します。
  - 再計算した署名と、受信したJWTの署名パートが完全に一致するかを比較します。一致しなければ、トークンは改ざんされているか、不正な発行元からのものなので、即座に検証を中止しエラーとします。
3. **クレームの検証**
  - `exp`（有効期限）: トークンが期限切れになっていないかを確認します。
  - `nbf`（有効開始日時）: トークンが有効期間内であるかを確認します。
  - `aud`（受信者）, `iss`（発行者）: 必要に応じて、トークンが意図した受信者・発行者のものかを確認します。
4. **検証完了** : すべての検証をパスした場合、そのトークンは正当なものと判断され、ペイロードからユーザー情報を抽出し、リクエストされた処理を続行します。

:::details Node.jsでの検証ミドルウェア実装例
```javascript
const jwt = require('jsonwebtoken');

/**
 * JWTを検証するExpressミドルウェア
 */
function verifyToken(req, res, next) {
  const authHeader = req.headers.authorization;

  // 1. ヘッダーの存在と形式を確認
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: '認証トークンが必要です。' });
  }

  // "Bearer "の部分を取り除き、トークン本体を取得
  const token = authHeader.split(' ')[1];
  const secretKey = process.env.JWT_SECRET || 'your-very-secret-key';

  try {
    // 2. jwt.verify()でトークンを検証
    // この関数内で、署名の検証と有効期限のチェックが自動的に行われる
    const decodedPayload = jwt.verify(token, secretKey);

    // 3. 検証成功後、リクエストオブジェクトにユーザー情報を格納
    req.user = decodedPayload;

    // 4. 次の処理へ
    next();
  } catch (error) {
    // 検証失敗時のエラーハンドリング
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ error: 'トークンの有効期限が切れています。' });
    }
    return res.status(401).json({ error: '無効なトークンです。' });
  }
}
```
:::

### 3.4 ステートレス認証の仕組み

JWT認証の核心的な利点は、**ステートレス**であることです。つまり、「サーバーがクライアントの状態を保持しない」という意味になります。

セッション認証（ステートフル）では、サーバーは「どのセッションIDがどのユーザーか」という対応表を常に自身のストレージに保持しておく必要がありました。

一方、JWT認証では、必要なユーザー情報はすべてJWT自体に含まれているため、サーバーは受け取ったJWTを検証するだけでよく、過去のリクエストやセッション情報を記憶しておく必要が一切ありません。

このステートレスな性質が、以下のようなメリットをもたらします。

- **サーバーの負荷軽減とシンプル化** : セッションストレージへの問い合わせが不要になるため、サーバーの負荷が減り、アーキテクチャもシンプルになります。
- **水平スケーリングの容易さ** : どのサーバーがリクエストを受け取っても、同じ秘密鍵さえ持っていればJWTを検証できます。そのため、サーバーの台数を増やすだけで簡単システム全体の性能を向上させることができます。
- **マイクロサービスとの高い親和性** : 各サービスが独立してJWTを検証できるため、サービス間の認証連携が非常にスムーズになります。

## 4. 署名アルゴリズムの理解

JWTのセキュリティを支える重要な要素の一つが、**署名アルゴリズム**です。この署名をどの「アルゴリズム」で作るかによって、システムのセキュリティや設計が大きく変わります。ここでは、主要な署名アルゴリズムである「対象鍵」と「非対称鍵」の違いを理解し、どのような状況でどちらを選ぶべきかなどを掘り下げていきます。

### 4.1 対称鍵アルゴリズム（HMAC系）

HMAC（Hash-based Message Authentication Code）は、**単一の「秘密鍵」を、署名の生成と検証**の両方に使用する方式です。関係者全員が同じ「合鍵」を持っているイメージです。

```mermaid
graph TD
    subgraph "HMAC (対称鍵) の仕組み"
        A(サーバーA) -- JWT発行 --> C(クライアント);
        C -- JWT提示 --> D(サーバーB);
        A -- "秘密鍵(Secret Key)" --> B((共通の秘密鍵));
        D -- "秘密鍵(Secret Key)" --> B;
    end
    style B fill:#fecdd3,stroke:#be123c
```

**メリット**
- **高速** : 非対称鍵方式に比べて、署名の生成・検証の計算が非常に高速です。
- **シンプル** : 鍵が一つだけなので、概念的に理解しやすく実装も比較的容易です。

**デメリット**
- **鍵の共有が必須** : 検証を行う全てのサーバーに、同じ秘密鍵を安全に配布する必要があります。
- **鍵漏洩のリスク集中** : 万が一秘密鍵が漏洩した場合、第三者が署名を偽造できてしまうため、影響範囲が大きくなります。

**主なアルゴリズム**
- `HS256`（HMAC using SHA-256）: 最も広く使われている推奨アルゴリズム。
- `HS384`, `HS512` : より強固なハッシュ関数を使用する、さらにセキュリティの高い選択肢。

### 4.2 非対称鍵アルゴリズム（RSA/ECDSA系）

非対称鍵アルゴリズムは、**「秘密鍵」と「公開鍵」**というペアの鍵を使用します。
- **秘密鍵** : 署名を生成するために使用。発行者だけが厳密に保管します。
- **公開鍵** : 署名を検証するために使用。検証が必要な関係者に配布できます。

```mermaid
graph TD
    subgraph "非対称鍵の仕組み"
        A(認証サーバー) -- "秘密鍵で署名" --> B(JWT);
        B --> C(クライアント);
        C --> D(APIサーバー1);
        C --> E(APIサーバー2);

        D -- "公開鍵で検証" --> B;
        E -- "公開鍵で検証" --> B;

        subgraph "鍵の配布"
            F(公開鍵) --> D;
            F --> E;
        end
    end
    style A fill:#cffafe,stroke:#0891b2
    style F fill:#dcfce7,stroke:#16a34a
```

**メリット**
- **高いセキュリティ** : 秘密鍵を外部に渡す必要がないため、HMAC方式より安全です。
- **柔軟な連携** : 公開鍵さえ共有すれば、第三者でも署名を検証できます。これらは、マイクロサービスや外部API連携に最適です。

**デメリット**
- **計算コスト** : HMAC方式に比べて、署名の生成・検証に時間がかかります。
- **鍵管理の複雑さ** : 鍵がペアになるため、管理が少し複雑になります。

**主なアルゴリズム**
- `RS256`（RSA Signature with SHA-256）: 広く使われているアルゴリズム
- `ES256`（ECDSA using P-256 and SHA-256）: RSAよりも短い鍵長で同等のセキュリティ強度を実現でき、パフォーマンスも良好なため、近年採用が増えている。

### 4.3 アルゴリズム選択のポイント

では、どちらのアルゴリズムを選べば良いのでしょうか。以下のフローチャートと考え方が参考になります。

```mermaid
flowchart TD
    A{認証は単一の<br>システム内で完結する？} -- Yes --> B{パフォーマンス要件は<br>非常に厳しい？};
    A -- No / 外部連携あり --> E[RS256 / ES256 を選択];

    B -- Yes --> C[HS256 を選択];
    B -- No --> D{秘密鍵の管理は<br>安全かつ容易？};

    D -- Yes --> C;
    D -- No --> E;

    subgraph "結論"
      C("推奨: HS256");
      E("推奨: RS256 / ES256");
    end
```

- **モノリシックなアプリケーションや、信頼できる少数のサービス間で完結する場合**
HS256がシンプルで高速なため、良い選択肢です。ただし、秘密鍵を安全に管理・共有できることが大前提になります。
- **マイクロサービスアーキテクチャや、外部のサードパーティにAPIを公開する場合**
秘密鍵を共有する必要がないRS256やES256が強く推奨されています。

### 4.4 セキュリティ上の重要な注意点

アルゴリズムの選択や実装を誤ると、深刻な脆弱性につながります。

1. **`none`アルゴリズムの無効化**
JWTの仕様には、署名は行わない`none`というアルゴリズムが存在します。これを許可してしまうと、署名検証がバイパスされ、誰でも自由に改ざんしたトークンを有効にできてしまいます。ライブラリの検証機能で、`olg`ヘッダーが`none`の場合は必ずエラーとするように設定してください。
2. **アルゴリズム混同攻撃への対策**
RS256の公開鍵を、HS256の秘密鍵として誤用される攻撃手法です。検証時には、必ず`algorithms`オプションで許可するアルゴリズムを明示的に指定し、意図しないアルゴリズムでの検証を防いでください。
```js
// 安全な検証の例
jwt.verify(token, publicKey, {
  // 必ずアルゴリズムを配列で明示的に指定する
  algorithms: ['RS256']
});
```
3. **強力な秘密鍵の使用**
`password`や`secret`のような推測しやすい秘密鍵は絶対に使用しないでください。暗号学的に安全な乱数生成器を使って、十分に長い（HS256なら32バイト/256ビット以上を推奨）複雑な文字列を生成し、環境変数やシークレット管理サービスで安全に管理してください。
4. **定期的な鍵のローテーション**
万が一秘密鍵が漏洩した場合の影響を最小限に抑えるため、定期的に鍵を更新（ローテーション）する運用が推奨されます。`kid`（Key ID）ヘッダーを使って複数の鍵を管理し、古いトークンも一定期間検証できるようにする仕組みが一般的です。

## 5. JWT実装の基本

### 5.1 開発環境の準備

### 5.2 JWTライブラリの選択

### 5.3 トークン生成の実装

### 5.4 トークン検証の実装

### 5.5 エラーハンドリング

## 6. バックエンドでの実装

### 6.1 Express.jsでの認証ミドルウェア

### 6.2 トークンの検証ロジック

### 6.3 ユーザー情報の抽出

### 6.4 保護されたルートの実装

## 7. フロントエンドでの実装

### 7.1 トークンの保存方法

### 7.2 APIリクエストでの認証ヘッダー

### 7.3 トークン期限の管理

### 7.4 自動ログアウトの実装

## 8. セキュリティ考慮事項

### 8.1 JWTの脆弱性と対策

### 8.2 秘密鍵の管理

### 8.3 トークンの有効期限設定

### 8.4 リフレッシュトークンの活用

## 9. JWT認証のメリット・デメリット

### 9.1 JWTのメリット

### 9.2 JWTのデメリット

### 9.3 セッション認証との比較

### 9.4 適用判断の指針

## 10. 実践的な運用のポイント

### 10.1 トークンの無効化戦略

### 10.2 パフォーマンス最適化

### 10.3 監視とログ管理

### 10.4 トラブルシューティング

## 11. テストとデバッグ

### 11.1 JWT認証のテスト戦略

### 11.2 単体テストの実装例

### 11.3 デバッグツールの活用

### 11.4 よくある問題と解決法

## まとめ

### JWT認証の適用ポイント

### 実装時のチェックリスト

### 参考資料
