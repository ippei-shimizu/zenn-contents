---
title: "JWT認証を仕組みから実装まで理解する"
emoji: "🛡️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [JWT, 認証, セキュリティ]
published: false
---

## はじめに

プログラミングスクールRUNTEQでWebエンジニア兼講師をしているいっぺい（[@ippei_111](https://x.com/ippei_111)）と申します。

いきなりですが、Web開発をしている中で「JWT認証って何となく使用しているけど、実際の仕組みはあまり理解できていない」「セッション認証とJWT認証の使い分けがわからない」などと感じたことはありませんか？

私自身、JWT認証についての理解が浅いと感じていたため、本記事では、JWT認証の基本的な仕組みから実装方法、セキュリティ面まで、体系的にまとめてみようと思います。

:::message
JWT認証はセキュリティに関わる重要な技術のため、間違った実装をすると深刻な脆弱性につながる可能性があります。
本記事では実装例も紹介しますが、実際のプロダクションで使用する際は、さらなるセキュリティ検証を行うことを強く推奨します。
また、間違っている説明や解釈などありましたら、ご指摘いただけると幸いです。
:::

## 1. JWT認証の基礎

まず、JWT認証の基本的な概念と、それがどのような背景から登場したのかを解説します。

### 1.1 JWTの登場背景と従来の認証方式の課題

従来のWebアプリケーションでは、「セッション・Cookie認証」が認証方式の主流でした。これは、サーバー側でユーザーの認証状態をセッションとして管理する方式です。

**セッション・Cookie認証の基本的な流れ**
1.  ユーザーがログインすると、サーバーはセッションIDを発行します。
2.  サーバーは、そのセッションIDとユーザー情報を紐付けて自身のストレージ（セッションストレージ）に保存します。
3.  クライアント（ブラウザ）は受け取ったセッションIDをCookieに保存し、以降のリクエストで常にそのCookieを送信します。
4.  サーバーは受け取ったセッションIDを元に、ストレージからユーザー情報を参照して認証状態を確認します。

この方法は長年広く使われてきましたが、アプリケーションの構成が複雑化するにつれて、いくつかの課題が顕在化しました。

![](/images/jwt-issue.png)

* **スケーラビリティ**: 負荷分散のためにサーバーを複数台構成にする場合、全サーバーでセッション情報を共有するための仕組み（スティッキーセッションや共有ストレージなど）が別途必要になり、構成が複雑化します。
* **クロスドメイン/クロスプラットフォーム**: Cookieのドメイン制約により、異なるドメインを持つサービス間での認証情報の共有が困難です。また、Cookieの仕組みを持たないネイティブアプリなど、Webブラウザ以外のクライアントとの相性も課題でした。
* **マイクロサービスアーキテクチャとの親和性**: サービスが機能ごとに分割されている場合、サービス間で認証状態を連携させるための仕組みが複雑になりがちです。

これらの課題を解決するアプローチとして登場したのが、**ステートレス**な認証を実現するJWT（JSON Web Token）です。

### 1.2 JWT（JSON Web Token）とは

JWTとは、情報を安全にやり取りするための国際的なルール（RFC 7519）として標準化された仕様の一つです。その実体は、`.`（ピリオド）で区切られた、URLセーフな文字列です。

**RFC 7519とは**
RFC 7519は、JWTの仕様を定義した文書で、JSON Web Tokenの構造や使用方法を規定しています。
https://tex2e.github.io/rfc-translater/html/rfc7519.html

JWTの例）
```bash
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

このJWTは、以下の3つのパートから構成されています。
1.  **ヘッダー (Header)**: トークンの種別（`typ`）と、署名アルゴリズム（`alg`）を定義するパートです。
2.  **ペイロード (Payload)**: ユーザーIDや権限、有効期限など、伝達したい情報（クレーム）を含むパートです。
3.  **署名 (Signature)**: ヘッダーとペイロードが改ざんされていないことを保証するためのデジタル署名です。

![](/images/jwt-kouzou.png)

この構造により、JWTは以下のような特徴を持ちます。

* **自己完結型 (Self-contained)**: トークン自体が認証に必要な情報を持っているため、サーバーは状態を保持するためのストレージにアクセスする必要がありません。
* **ステートレス (Stateless)**: サーバー側で認証状態を管理しないため、リクエストをどのサーバーで処理してもよく、スケーラビリティを確保しやすくなります。
* **改ざん耐性**: デジタル署名によって、トークンの内容が途中で書き換えられていないかを検証できます。

### 1.3 認証方式の比較：セッション認証とJWT認証

ここで、2つの認証方式の主な違いを整理します。最も本質的な違いは、**認証状態をどこで管理するか（ステートフルかステートレスか）** という点です。

* **セッション・Cookie認証**: サーバー側で状態を管理する**ステートフル**な方式。
* **JWT認証**: トークン自体が情報を持ち、サーバーは状態を持たない**ステートレス**な方式。

この違いが、それぞれの特性に影響を与えます。

![](/images/jwt-cookie-jwt.png)

| 項目       | セッション・Cookie認証 | JWT認証      |
|----------|----------------|------------|
| 状態管理     | ステートフル（サーバーが状態を保持）         | ステートレス（サーバーは状態を持たない）     |
| サーバー負荷   | セッションストレージへのアクセスが必要  | 署名の暗号計算のみで済む    |
| 拡張性       | サーバー増設時にセッション共有の考慮が必要  | サーバーを増やしやすい（水平スケールが容易） |
| トークンサイズ  | 小さい（セッションIDのみ） | 大きい（情報を含む） |
| 強制無効化   | サーバー側でセッションを破棄すればOK（容易）  | 有効期限まで原則有効（工夫が必要） |
| 外部連携  | Cookieの制約により困難な場合がある | トークンを渡すだけで連携可能（容易） |
| モバイル対応   | Cookieの扱いに注意が必要 | ヘッダーでの送受信が基本で相性が良い  |

## 2. JWTの構造を深く知る

JWTが単なる長い文字列ではないことは、理解できたと思います、ここでは、その文字列を構成する「ヘッダー」「ペイロード」「署名」の3つのパートを、さらに詳しく見ていきます。

### 2.1 ヘッダー

ヘッダーは、そのJWTが「どのようなトークンで、どのように署名されているか」を定義するメタデータ部分です。具体的には、以下の2つの情報を含むJSONオブジェクトで構成されるのが一般的です。

- `alg`（Algorithm）: 署名を生成するために使用されるアルゴリズムを指定します。例えば、`HS256`（HMAC SHA-256）や`RS256`（RSA SHA-256）などがあります。
- `typ`（Type）: トークンのタイプを指定します。JWTの場合は通常`JWT`が指定されます。
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
このJSONオブジェクトがBase64URLエンコードされ、JWTの最初の部分（ヘッダー）を形成します。

### 2.2 ペイロード

ペイロードは、トークンを通じて伝えたい情報であり、「クレーム（Claims）」を格納する部分です。クレームとは、ユーザーIDや名前、権限、トークンの有効期限など、情報の断片を指します。
```json
{
  "sub": "user-12345",
  "name": "John Doe",
  "role": "admin",
  "exp": 1720854720
}
```
このペイロードもヘッダーと同様に、Base64URLエンコードされ、JWTの2番目の部分を形成します。

クレームには、用途に応じて3つの種類があります。

1. **登録済みクレーム（Registered Claims）**
仕様としてあらかじめ定義されているクレームです。これらは必須ではありませんが、相互運用性を高めるために使用が推奨されています。

| クレーム | 説明                                    |
|----------|-----------------------------------------|
| `iss`    | (Issuer) 発行者                         |
| `sub`    | (Subject) このJWTの主題（ユーザーIDなど） |
| `aud`    | (Audience) このJWTの受信者              |
| `exp`    | (Expiration Time) 有効期限（Unixタイムスタンプ） |
| `iat`    | (Issued At) 発行日時（Unixタイムスタンプ） |
| `nbf`    | (Not Before) 有効期間の開始日時         |
| `jti`    | (JWT ID) トークンの一意な識別子         |

2. **パブリッククレーム（Public Claims）**
JWTの利用者が自由に定義できるクレームですが、他のシステムと重複しないように、[IANA JSON Web Token Claims Registry](https://www.iana.org/assignments/jwt/jwt.xhtml) で管理されている名前を使用するか、衝突しないURI形式の名前空間を持つ名前を定義する必要があります。

https://www.iana.org/assignments/jwt/jwt.xhtml

3. **プライベートクレーム（Private Claims）**
発行者と受信者の間で合意の上で自由に使用される、アプケーション固有のクレームです。`userId`や`role`など、アプリケーションが必要とする情報をここに格納します。

:::message alert
ペイロードは暗号化されているわけではありません。Base64URLエンコードは、単なるデータの表現形式の変換であり、誰でも簡単にでコードして中身を閲覧することができます。
したがって、ペイロードにはパスワードやクレジットカード番号などの機密情報を絶対に含めないでください。
:::

### 2.3 署名

署名は、JWTの最も重要なセキュリティ機能です。この署名があることで、以下の2点を保証することができます。

- **完全性（Integrity）** : トークンが途中で改ざんされていないこと。
- **認証（Authentication）** : トークンが信頼できる発行者によって作成されたものであること。

署名は、以下の手順で生成されます。

HMACSHA256( Base64URL(ヘッダー) + "." + Base64URL(ペイロード), 秘密鍵 )

つまり、「エンコードされたヘッダー」と「エンコードされたペイロード」を`.`で連結した文字列を、ヘッダーで指定されたアルゴリズムと、サーバーだけが知っている秘密鍵を使って計算したハッシュ値です。

この秘密鍵を知らない第三者は、たとえヘッダーやペイロードを改ざんしても、正しい署名を再生成することができません。サーバーはリクエストを受け取るたびに、同じ方法で署名を計算し直し、送られてきた署名と一致するかを検証することで、トークンの正当性を確認します。

### 2.4 Base64URLエンコーディングとは？

JWTの各パートを構成するBase64URLエンコーディングについて補足します。これは、バイナリデータをテキストデータに変換するBase64を、URLで安全に使用できるように改良したものです。

通常のBase64では、URLにおいて特別な意味を持つ文字（`+`や`-`）や、パディングのための`=`が使われます。Base64URLでは、これらの文字をURLにセーフな文字に置き換え、パディングを削除しています。

このエンコーディングにより、JWTはHTTPヘッダーやURLクエリパラメータとして、問題なく安全に含めることができるのです。

https://qiita.com/kunihiros/items/2722d690b1525813c45e

## 3. JWT認証の動作原理

### 3.1 認証フローの全体像

### 3.2 トークンの生成プロセス

### 3.3 トークンの検証プロセス

### 3.4 ステートレス認証の仕組み

## 4. 署名アルゴリズムの理解

### 4.1 対称鍵アルゴリズム（HMAC系）

### 4.2 非対称鍵アルゴリズム（RSA/ECDSA系）

### 4.3 アルゴリズム選択の考慮点

### 4.4 セキュリティ上の注意点

## 5. JWT実装の基本

### 5.1 開発環境の準備

### 5.2 JWTライブラリの選択

### 5.3 トークン生成の実装

### 5.4 トークン検証の実装

### 5.5 エラーハンドリング

## 6. バックエンドでの実装

### 6.1 Express.jsでの認証ミドルウェア

### 6.2 トークンの検証ロジック

### 6.3 ユーザー情報の抽出

### 6.4 保護されたルートの実装

## 7. フロントエンドでの実装

### 7.1 トークンの保存方法

### 7.2 APIリクエストでの認証ヘッダー

### 7.3 トークン期限の管理

### 7.4 自動ログアウトの実装

## 8. セキュリティ考慮事項

### 8.1 JWTの脆弱性と対策

### 8.2 秘密鍵の管理

### 8.3 トークンの有効期限設定

### 8.4 リフレッシュトークンの活用

## 9. JWT認証のメリット・デメリット

### 9.1 JWTのメリット

### 9.2 JWTのデメリット

### 9.3 セッション認証との比較

### 9.4 適用判断の指針

## 10. 実践的な運用のポイント

### 10.1 トークンの無効化戦略

### 10.2 パフォーマンス最適化

### 10.3 監視とログ管理

### 10.4 トラブルシューティング

## 11. テストとデバッグ

### 11.1 JWT認証のテスト戦略

### 11.2 単体テストの実装例

### 11.3 デバッグツールの活用

### 11.4 よくある問題と解決法

## まとめ

### JWT認証の適用ポイント

### 実装時のチェックリスト

### 参考資料
