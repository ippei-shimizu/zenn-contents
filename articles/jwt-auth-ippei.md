---
title: "JWT認証を仕組みから実装まで理解する"
emoji: "🛡️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [JWT, 認証, セキュリティ]
published: false
---

## はじめに

プログラミングスクールRUNTEQでWebエンジニア兼講師をしているいっぺい（[@ippei_111](https://x.com/ippei_111)）と申します。

いきなりですが、Web開発をしている中で「JWT認証って何となく使用しているけど、実際の仕組みはあまり理解できていない」「セッション認証とJWT認証の使い分けがわからない」などと感じたことはありませんか？

私自身、JWT認証についての理解が浅いと感じていたため、本記事では、JWT認証の基本的な仕組みから実装方法、セキュリティ面まで、体系的にまとめてみようと思います。

:::message
JWT認証はセキュリティに関わる重要な技術のため、間違った実装をすると深刻な脆弱性につながる可能性があります。
本記事では実装例も紹介しますが、実際のプロダクションで使用する際は、さらなるセキュリティ検証を行うことを強く推奨します。
また、間違っている説明や解釈などありましたら、ご指摘いただけると幸いです。
:::

## 1. JWT認証の基礎

まず、JWT認証の基本的な概念と背景を理解していきます。

### 1.1 Web認証の課題とJWTの登場背景

#### 従来の認証システムの課題

Webアプリケーションにおける従来の認証方法では、主にセッション・Cookieを使用した方法が一般的でした。
しかし、現代のWeb開発では以下のような課題が顕在化してきました。

![](/images/jwt-issue.png)

これらの課題を解決するために登場したのがJWT（JSON Web Token）です。
主な解決ポイントしては以下のようなものがあります。
- **ステートレス** : サーバー側でセッション情報を保持する必要がない。
- **自己完結型** : トークン自体に必要な情報が含まれている
- **標準化** : RFC 7519で定義されており、広く採用されている。
- **クロスプラットフォーム対応** : Web、モバイル、デスクトップアプリなどで共通の認証方式として利用可能。

**RFC 7519とは**
RFC 7519は、JWTの仕様を定義した文書で、JSON Web Tokenの構造や使用方法を規定しています。
https://tex2e.github.io/rfc-translater/html/rfc7519.html

### 1.2 JWT（JSON Web Token）とは

#### JWTの定義

JWT（JSON Web Token）は、当事者間で安全に情報を送信するためのコンパクトで、URLセーフな手段を定義するオープンスタンダードです。

#### JWTの基本構造

JWTは、3つの部分をピリオド（`.`）で区切った文字列で構成されています。

例）
```bash
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

この文字列は、以下の3つの部分で構成されています。
1. **Header（ヘッダー）** : トークンの種類と、署名の生成に使用されるアルゴリズム（alg、例: "HS256"や"RS256"）をJSON形式で指定します。このJSONオブジェクトは、Base64urlエンコードされてJWTの最初の部分になります。
2. **Payload（ペイロード）** : クレーム（Claims）と呼ばれる、ユーザー情報や有効期限などのデータを含む部分です。クレームには、発行者（iss）や失効日時（exp）などを定義する登録済みクレーム、自由に定義できるプライベートクレームなどがあります。この部分もBase64urlエンコードされてJWTの2番目の部分になります。
3. **Signature（署名）** : エンコードされたヘッダーとペイロードをピリオドで連結し、ヘッダーで指定されたアルゴリズムと秘密鍵を使って生成されます。この署名により、JWTが改ざんされていないことを検証できます。

![](/images/jwt-kouzou.png)

#### JWTの特徴

- **自己完結型（Self-contained）** : トークン自体に必要な情報が全て含まれているため、データベースへの問い合わせが不要。
- **ステートレス（Stateless）** : サーバー側で状態を保持する必要がなく、水平スケーリングが容易。
- **デジタル署名** : トークンの改ざんを検知できるため、セキュリティが高い。

### 1.3 従来の認証方式との違い

#### セッション・Cookie認証 vs JWT認証

セッション・Cookie認証とJWT認証の最も大きな違いは、「どこで認証状態を管理するか」という点にあります。

セッション・Cookie認証では、サーバー側がセッションIDに対応するユーザー情報を保持（ステートフル）し、リクエストごとに照合します。
一方、JWT認証では、トークン自体がユーザー情報や有効期限を含んでいるため、サーバーは状態を保持する必要がありません（ステートレス）。サーバーは受け取ったJWTの署名を検証するだけで済みます。

以下の図は、それぞれの認証フローの違いを視覚的に表したものです。

![](/images/jwt-cookie-jwt.png)

| 項目       | セッション・Cookie認証 | JWT認証      |
|----------|----------------|------------|
| 状態管理     | ステートフル         | ステートレス     |
| サーバー負荷   | セッションストレージが必要  | ストレージ不要    |
| スケーラビリティ | 制限あり           | 優秀         |
| トークンサイズ  | 小さい（セッションIDのみ） | 大きい（情報を含む） |
| 即座な無効化   | 容易             | 困難         |
| クロスドメイン  | 制限あり           | 容易         |
| モバイル対応   | 制限あり           | 優秀         |

## 2. JWTの構造を理解する

### 2.1 JWTの3つの構成要素

### 2.2 Header（ヘッダー）の詳細

### 2.3 Payload（ペイロード）とクレーム

### 2.4 Signature（署名）の役割

### 2.5 Base64URLエンコーディング

## 3. JWT認証の動作原理

### 3.1 認証フローの全体像

### 3.2 トークンの生成プロセス

### 3.3 トークンの検証プロセス

### 3.4 ステートレス認証の仕組み

## 4. 署名アルゴリズムの理解

### 4.1 対称鍵アルゴリズム（HMAC系）

### 4.2 非対称鍵アルゴリズム（RSA/ECDSA系）

### 4.3 アルゴリズム選択の考慮点

### 4.4 セキュリティ上の注意点

## 5. JWT実装の基本

### 5.1 開発環境の準備

### 5.2 JWTライブラリの選択

### 5.3 トークン生成の実装

### 5.4 トークン検証の実装

### 5.5 エラーハンドリング

## 6. バックエンドでの実装

### 6.1 Express.jsでの認証ミドルウェア

### 6.2 トークンの検証ロジック

### 6.3 ユーザー情報の抽出

### 6.4 保護されたルートの実装

## 7. フロントエンドでの実装

### 7.1 トークンの保存方法

### 7.2 APIリクエストでの認証ヘッダー

### 7.3 トークン期限の管理

### 7.4 自動ログアウトの実装

## 8. セキュリティ考慮事項

### 8.1 JWTの脆弱性と対策

### 8.2 秘密鍵の管理

### 8.3 トークンの有効期限設定

### 8.4 リフレッシュトークンの活用

## 9. JWT認証のメリット・デメリット

### 9.1 JWTのメリット

### 9.2 JWTのデメリット

### 9.3 セッション認証との比較

### 9.4 適用判断の指針

## 10. 実践的な運用のポイント

### 10.1 トークンの無効化戦略

### 10.2 パフォーマンス最適化

### 10.3 監視とログ管理

### 10.4 トラブルシューティング

## 11. テストとデバッグ

### 11.1 JWT認証のテスト戦略

### 11.2 単体テストの実装例

### 11.3 デバッグツールの活用

### 11.4 よくある問題と解決法

## まとめ

### JWT認証の適用ポイント

### 実装時のチェックリスト

### 参考資料
