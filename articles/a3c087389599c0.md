---
title: "Fat Controllerをリファクタリングしたい"
emoji: "🙄"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Ruby", "Rails"]
published: false
---

## はじめに

ここ数ヶ月間でRailsを使用したアプリケーションの新規機能開発を担当し、見事**Fat Controller**を実装してしまいました。
そのため、振り返りとして**単一責務の原則**に則った実装や抽象化したクラスの作成方法など、Fat Controllerをリファクタリングしながら問題点や改善策についてまとめていきたいと思います。

## Fat Controllerとは

まず、改めてFat Controllerとはどういった状態のものなのかについて整理します。

> コントローラに置くロジックを増やしすぎたときの問題は、単一責任の原則（SRP: Single Responsibility Principle）に違反することです。つまり、処理をコントローラ内で引き受けすぎてしまっているということです。この状態になるとコード量が増えて責務を抱え込みすぎてしまいがちです。ここでいう「ファット」は、コントローラファイルのコード量も、コントローラがサポートするロジックの量も増えるということを指します。ファットコントローラは多くの場合アンチパターンと見なされます。

https://techracho.bpsinc.jp/hachi8833/2021_10_05/112108

ようは、**コントローラーが過剰な責務を持ってしまい、肥大化してしまっている状態**のことを言います。
結果として、色々な責務を持っているコントローラーになってしまうと、**可読性の低いコード・変更に弱いコード・再利用性の低いコード** になってしまいます。

そのため、Fat Controllerにならないように実装をするには「単一責務の原則」の考えが大切になります。

## 単一責務の原則

次に、改めて単一責務の原則についても整理してみます。

> クラス（オブジェクト）が担う責任は1つに限定すべきである（かつその責務は完全にカプセル化されるべきである）。

https://techracho.bpsinc.jp/hachi8833/2018_03_27/54130

つまり、1つのクラスやモジュールが複数の責務を持つのではなく、1つの明確な責務だけを担うべきという考え方になります。
この原則を意識することで、コードの可読性・保守性が向上します。

では、次に単一責務の原則についてBAD・GOODなコード例をみてみましょう。

### 🙅‍♂️ BAD

以下のコードはフルーツのECサイトを例として考えた際のコンローラーになります。
index, show, searchのアクションが実装されており、責務が混在してしまっています。また、少し極端ではありますが、各アクションのデータ整形のロジックが重複してしまっています。

```rb:app/controllers/api/fruits_controller.rb
class Api::FruitsController < ApplicationController
  def index
    fruits = Fruit.all
    result = fruits.map do |fruit|
      {
        id: fruit.id,
        name: fruit.name,
        price: fruit.price,
        in_stock: fruit.stock > 0
      }
    end
    render json: result
  end

  def show
    fruit = Fruit.find(params[:id])
    render json: {
      id: fruit.id,
      name: fruit.name,
      price: fruit.price,
      in_stock: fruit.stock > 0
    }
  end

  def search
    fruits = Fruit.where('name LIKE ?', "%#{params[:query]}%")
    result = fruits.map do |fruit|
      {
        id: fruit.id,
        name: fruit.name,
        price: fruit.price,
        in_stock: fruit.stock > 0
      }
    end
    render json: result
  end
end
```

### 🙆‍♂️ GOOD

以下のように、`fruits_controller.rb` にはデータ取得系のアクションを実装し、検索の責務を持つアクションについては `fruits/search_controller.rb` へ切り出しました。これにより、各コントローラーの責務が明確になり、単一責務の原則に則った実装になります。

また、ActiveRecordのクエリロジックは `models/fruit.rb` にスコープとして切り出し、再利用性と保守性を向上させています。さらに、データ整形の責務を専用のシリアライザ `fruit_serializer.rb` に分離することで、コントローラーが軽量化され、ロジックがシンプルになりました。

```rb:app/controllers/api/fruits_controller.rb
class Api::FruitsController < ApplicationController
  def index
    fruits = Fruit.cheap(500) # 例: 500円以下のフルーツ
    render json: fruits.map { |fruit| FruitSerializer.new(fruit).as_json }
  end

  def show
    fruit = Fruit.find(params[:id])
    render json: FruitSerializer.new(fruit).as_json
  end
end
```

```rb:app/controllers/api/fruits/search_controller.rb
class Api::Fruits::SearchController < ApplicationController
  def search
    fruits = Fruit.search_by_name(params[:query])
    render json: fruits.map { |fruit| FruitSerializer.new(fruit).as_json }
  end
end
```

```rb:app/models/fruit.rb
class Fruit < ApplicationRecord
  scope :cheap, ->(max_price) { where('price <= ?', max_price) }
  scope :search_by_name, ->(query) { where('name LIKE ?', "%#{query}%") }
end

```

```rb:app/serializers/fruit_serializer.rb
class FruitSerializer
  def initialize(fruit)
    @fruit = fruit
  end

  def as_json
    {
      id: @fruit.id,
      name: @fruit.name,
      price: @fruit.price,
      in_stock: @fruit.stock > 0
    }
  end
end
```

## 私が実装したFat Controller

次に私が実装したFat Controllerのコードを元に問題点とリファクタリング案を考えていきたいと思います。
今回もフルーツECサイトを仮定して説明します。

:::message alert
実際に実務で使用したコードを元に、記事用に別のコンテキストで実装したコードになります。
そのため、実際の使用しているコードではありません。
:::

かなり長いコードになってしまうため、問題点となる箇所だけ説明します。

**🙅‍♂️ BAD**

```rb:app/api/fruits/orders_controllers.rb
class Api::Fruits::OrdersController < Api::BaseController
  before_action :set_order, only: %i[update cancel details]
  before_action :validate_cart, only: %i[create]

  
  def current_order_summary
    current_order = current_user.orders.where(status: 'in_progress').last

    if current_order.blank?
      render json: { order_status: false }
    else
      order_items = current_order.order_items.includes(:product)
      total_price = order_items.sum { |item| item.product.price * item.quantity }
      shipping_address = current_order.shipping_address

      order_summary = {
        id: current_order.id,
        status: current_order.status,
        shipping_address: shipping_address,
        total_price: total_price,
        items: order_items.map do |item|
          {
            product_name: item.product.name,
            quantity: item.quantity,
            price: item.product.price
          }
        end
      }
      render json: { order_status: true, order_summary: order_summary }
    end
  end

  def create
    new_order = current_user.orders.build(order_params)

    if new_order.save
      cart.items.each do |cart_item|
        new_order.order_items.create(product_id: cart_item.product_id, quantity: cart_item.quantity)
      end
      cart.clear
      render json: { message: 'Order created successfully', order_id: new_order.id }, status: :created
    else
      render json: { message: 'Failed to create order', errors: new_order.errors.full_messages }, status: :unprocessable_entity
    end
  end

  def update
    if @order.update(order_params)
      render json: { message: 'Order updated successfully', order: @order }, status: :ok
    else
      render json: { message: 'Failed to update order', errors: @order.errors.full_messages }, status: :unprocessable_entity
    end
  end

  def details
    if @order.present?
      order_details = {
        id: @order.id,
        status: @order.status,
        items: @order.order_items.map do |item|
          {
            product_name: item.product.name,
            quantity: item.quantity,
            price: item.product.price
          }
        end,
        total_price: @order.order_items.sum { |item| item.product.price * item.quantity },
        shipping_address: @order.shipping_address
      }
      render json: { order: order_details }, status: :ok
    else
      render json: { message: 'Order not found' }, status: :not_found
    end
  end

  def cancel
    if @order.cancelable?
      @order.update(status: 'canceled')
      render json: { message: 'Order canceled successfully' }, status: :ok
    else
      render json: { message: 'Order cannot be canceled' }, status: :unprocessable_entity
    end
  end

  def search
    keyword = params[:keyword]
    orders = current_user.orders.joins(order_items: :product)
                     .where('products.name ILIKE ?', "%#{keyword}%")
                     .distinct

    if orders.present?
      search_results = orders.map do |order|
        {
          id: order.id,
          status: order.status,
          total_price: order.order_items.sum { |item| item.product.price * item.quantity },
          items: order.order_items.map do |item|
            {
              product_name: item.product.name,
              quantity: item.quantity,
              price: item.product.price
            }
          }
        }
      end
      render json: { results: search_results }, status: :ok
    else
      render json: { message: 'No orders found matching the search criteria' }, status: :not_found
    end
  end

  def past_orders
    past_orders = current_user.orders.where(status: 'completed').order(created_at: :desc)

    if past_orders.present?
      past_orders_data = past_orders.map do |order|
        {
          id: order.id,
          status: order.status,
          completed_at: order.updated_at.strftime('%Y-%m-%d %H:%M'),
          total_price: order.order_items.sum { |item| item.product.price * item.quantity },
          items: order.order_items.map do |item|
            {
              product_name: item.product.name,
              quantity: item.quantity,
              price: item.product.price
            }
          }
        }
      end
      render json: { past_orders: past_orders_data }, status: :ok
    else
      render json: { message: 'No past orders found' }, status: :not_found
    end
  end

  private

  def set_order
    @order = current_user.orders.find_by(id: params[:id])
    unless @order
      render json: { message: 'Order not found' }, status: :not_found
    end
  end

  def order_params
    params.require(:order).permit(:shipping_address, :payment_method, order_items_attributes: %i[product_id quantity])
  end

  def validate_cart
    if cart.items.empty?
      render json: { message: 'Your cart is empty' }, status: :unprocessable_entity
    end
  end

  def cart
    @cart ||= current_user.cart
  end
end

```


## 参考情報
https://techracho.bpsinc.jp/hachi8833/2021_10_05/112108
https://techracho.bpsinc.jp/hachi8833/2018_03_27/54130
