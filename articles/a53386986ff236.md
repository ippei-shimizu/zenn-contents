---
title: "useEffectの基本的なアンチパターン"
emoji: "🙅‍♂️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react","javascript"]
published: false
---

## はじめに

今回は、Reactのフックの１つである**useEffect**のアンチパターンについて調べてみようと思った背景としては、現場のプロジェクトでuseEffect警察（フロントつよつよエンジニアさん）に「不要なuseEffectを使用してしまっている」というレビューをいただいたのがきっかけになります。

私はこれまで何となくuseEffectを使いまくることは良くないという認識でいましたが、具体的にどのようなユースケースでuseEffectを使用すると良くないのかまで理解できていなかったため、今回改めて調べてみようと思いました。

:::message
間違っている説明や解釈などありましたら、ご指摘いただけると幸いです。
:::

## useEffectとは

最初にuseEffectの基本について説明します。

useEffectはReactのフックの一つで、副作用を管理するために使用されます。このフックを使用することで、コンポーネントのレンダリング後に特定の関数を実行するタイミングを制御することができます。

:::message
**副作用とは**
コンポーネントのレンダリングプロセスの外部で行われる操作のことを指します。具体的には、データフェッチ・DOM操作・ログの記録などが挙げられます。
:::

### 基本的な実装方法

```jsx
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // 副作用のロジックをここに書きます

    return () => {
      // クリーンアップのロジックをここに書きます
    };
  }, []); // 依存配列
}
```

#### 依存配列について

- 依存配列に特定の値を指定することで、その値が変更されるたびにuseEffect内の副作用を実行することができます。
- 空の配列`[]`の場合は、初回レンダリング時のみ副作用が実行されます。
 
#### クリーンアップ関数について

- useEffect内で設定した副作用をクリーンアップするための関数になります。これにより、メモリークを防ぎコンポーネントのパフォーマンスの向上させることができます。
- クリーンアップの実行タイミング
  - コンポーネントのマウント時に初回のエフェクト（副作用）が発火されます。クリーンアップ関数は以下のタイミングで実行されます。
    - コンポーネントのアンマウント時。
    - コンポーネントの再レンダリング時。

**[クリーンアップ関数の実装例（タイマーのクリア）]**

```jsx
useEffect(() => {
  const timer = setTimeout(() => {
    console.log('1秒後に実行される');
  }, 1000);
  
  return () => clearTimeout(timer);
}, []);
```

このuseEffectの処理は以下のような機能を持っています。

1. コンポーネントがマウントされたときに、1秒後に実行されるタイマーを設定します。
2. コンポーネントがアンマウントされるときに、クリーンアップ関数が呼ばれて設定されたタイマーをクリアします。

このようにクリーンアップ関数を使用することで、不要なタイマーの実行を防ぎ、メモリリークや予期しない挙動を回避することができます。

👇 クリーンアップ関数についてはこちらの記事がとてもわかりやすかったです。

https://zenn.dev/yumemi_inc/articles/react-effect-simply-explained

👇 詳しくは公式ドキュメントをご覧ください。
https://ja.react.dev/reference/react/useEffect

## 不要なuseEffectを使用してしまった実装

次に、私が不要なuseEffectを使用してしまったユースケースについて簡単に説明したいと思います。

- **実装した機能**
  - リスト形式で表示しているデータをセレクトボックスで選択された値でフィルタリングする機能。
  - セレクトボックスで選択した値のidをURLのクエリパラメーターに設定して、設定されたクエリパラメーターを読み取り、そのidをリクエストで送信することで、選択されたデータを取得します。

↓ 画面イメージ

![](https://storage.googleapis.com/zenn-user-upload/28d3a756c0b6-20240702.png)

私はこのユースケースで、子コンポーネントのセレクトボックスに選択した「カテゴリー名」を表示させるために、useEffectを使用してクエリパラメータの値が変更されたら、useEffectの処理を発火させる実装を行なってしまいました。

この実装では、クエリパラメータの値が更新されたタイミングでReactコンポーネントが再レンダリングされるため、useEffectを使用しないでもセレクトボックスに新たに選択した「カテゴリー名」を設定することができます。

そのため、今回の実装でuseEffectを使用してしまうと、不要なレンダリングが発生してしまいます。

**[今回の実装での再レンダリングの流れ]**

```text
1.ユーザーがセレクトボックスでカテゴリーを選択 
↓
2. URLのクエリパラメータの更新 
↓
3. Reactコンポーネントの再レンダリング
↓
4. 現在のカテゴリー名の再計算
```

この「再レンダリングの流れ」により、クエリパラメータが更新されたタイミングで再レンダリングが発生するので、useEffectは不要な実装になっていました。

:::message
**レンダリングとは**
Reactコンポーネントの状態（state）やプロパティ（props）に基づいて、DOMを描画するプロセスのことです。このプロセスには**初回レンダリング**と**再レンダリング**のフェーズがあります。

**初回レンダリング**
ReactDOM.render()により、ReactコンポーネントをブラウザのDOMにマウントします。
コンポーネントのレンダリングにより、関数コンポーネントの戻り値を評価して、仮想DOMを生成します。
その後、仮想DOMと実際のDOMの差分を計算して、必要な部分のみ実際のDOMに反映させます。

**再レンダリング**
stateやpropsの変更に応じてコンポーネントが再評価されるプロセスになります。
変更されたstateやpropsに基づいてrenderメソッドや関数コンポーネントを評価して、新しい仮想DOMを生成します。

:::

👇 Reactコンポーネントの再レンダリングについては以下の記事がすごくわかりやすかったです。

https://zenn.dev/b1essk/articles/react-re-rendering

https://qiita.com/yokoto/items/ee3ed0b3ca905b9016d3

## 基本的なアンチパターン

では、次にuseEffectの基本的なアンチパターンについてコード例を用いて解説していきます。
これらのアンチパターンは、公式ドキュメントに記載されている内容を元にしています。

https://ja.react.dev/learn/you-might-not-need-an-effect

## 1. レンダーのためのデータ変換

- 「レンダーのためのデータ変換」とは
  - Reactコンポーネントがレンダリングされる際に、表示するデータを適切な形式に変換すること。
  - コンポーネントが受け取ったデータを表示する前にフィルタリングしたりした上で表示すること。

**[よくある実装]**

- リストのフィルタリング
- データの並び替え
- 計算結果の表示

### リストデータのフィリタリングをトップレベルで行う例

データの絞り込みを行う検索フォームコンポーネントを親として、データをフィルタリングしてリスト表示するコンポーネントを子とした例で実装してみます。

#### ❌ BAD

**search_form.jsx [親コンポーネント]**
検索フィールドに入力された値を子コンポーネントに渡しています。

```jsx:search_form.jsx
"use client";
import FilteredListNotGood from "@/app/useEffect/_components/filtered_list_not_good";
import { useState } from "react";

export default function SearchForm() {
  // inputに入力された値を保持する
  const [filter, setFilter] = useState("");
  // テストデータ
  const testListData = ["apple", "banana", "orange", "pear"];

  const handleSearchChange = (e) => {
    setFilter(e.target.value);
  };
  return (
    <>
      <input
        type="text"
        placeholder="果物をフィルタリング..."
        value={filter}
        onChange={handleSearchChange}
        className="border border-gray-300 rounded-md p-2"
      />
      <FilteredListNotGood list={testListData} filter={filter} />
    </>
  );
}
```

**filtered_list_not_good.jsx [子コンポーネント]**
親から渡ってきたpropsを受け取り、useEffectを使用して親の入力値が変更されたらフィルタリング処理を発火させる実装を行なっています。

```jsx:filtered_list_not_good.jsx
import React, { useState, useEffect } from "react";

export default function FilteredListNotGood({ list, filter }) {
  const [filteredItems, setFilteredItems] = useState([]);

  useEffect(() => {
    const filtered = list.filter((item) => item.includes(filter));
    setFilteredItems(filtered);
  }, [list, filter]);

  return (
    <ul>
      {filteredItems.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}
```

**ブラウザでの表示**

![](https://storage.googleapis.com/zenn-user-upload/10190fa9f3d8-20240702.gif)

この時の親と子コンポーネントのレンダリング回数を「[React Developer Tools](https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=ja)」を使用して確認してみます。

![](https://storage.googleapis.com/zenn-user-upload/d259212206d0-20240702.png)

↑こちらは親コンポーネントのレンダリング回数を計測しています。検索フォームに3文字入力してので、3回再レンダリングが発生しています。

![](https://storage.googleapis.com/zenn-user-upload/0dc2d9d6fd8b-20240702.png)

↑それに対して、子コンポーネントは倍の6回も再レンダリングが発生してしまっています。

なぜ、子コンポーネントが親コンポーネントの倍もレンダリングが発生してしまっているかというと、親コンポーネントでinputフィールドに入力がされるたびにstateが更新されて再レンダリングが発生しているため、子コンポーネントでuseEffectを使用しないでもデータを更新することができているためになります。

#### ⭕️ GOOD

親コンポーネントは先ほどのコードと同じものを使用して、子コンポーネントのみuseEffectを使用していない形に変更します。

**filtered_list_good.jsx [子コンポーネント]**

```jsx:filtered_list_good.jsx
import React from "react";

export default function FilteredListGood({ list, filter }) {
  const filteredItems = list.filter((item) => item.includes(filter));

  return (
    <ul>
      {filteredItems.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}
```

↓この変更により、子コンポーネントのレンダリング回数が3回になりました。

![](https://storage.googleapis.com/zenn-user-upload/499018afb5d7-20240702.png)

このように、親コンポーネントで再レンダリングが発生している際に、子コンポーネントでpropsの値を発火基準にしてuseEffectを使用してしまうと、不要な再レンダリングが発生してしまうケースがあります。

## 2. ユーザーイベントの処理にはエフェクトは必要ない

## 参考情報

https://ja.react.dev/reference/react/useEffect
