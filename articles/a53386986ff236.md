---
title: "useEffectの基本的なアンチパターン"
emoji: "🙅‍♂️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react","javascript"]
published: false
---

## はじめに

今回は、Reactのフックの１つである**useEffect**のアンチパターンについて調べてみようと思った背景としては、現場のプロジェクトでuseEffect警察（フロントつよつよエンジニアさん）に「不要なuseEffectを使用してしまっている」というレビューをいただいたのがきっかけになります。

私はこれまで何となくuseEffectを使いまくることは良くないという認識でいましたが、具体的にどのようなユースケースでuseEffectを使用すると良くないのかまでを理解できていなかったため、今回改めて調べてみようと思いました。

:::message
間違っている説明や解釈などありましたら、ご指摘いただけると幸いです。
:::

## useEffectとは

最初にuseEffectの基本について説明します。

useEffectはReactのフックの一つで、副作用を管理するために使用されます。このフックを使用することで、コンポーネントのレンダリング後に特定の関数を実行するタイミングを制御することができます。

:::message
**副作用とは**
コンポーネントのレンダリングプロセスの外部で行われる操作のことを指します。具体的には、データフェッチ・DOM操作・ログの記録などが挙げられます。
:::

### 基本的な実装方法

```jsx
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // 副作用のロジックをここに書きます

    return () => {
      // クリーンアップのロジックをここに書きます
    };
  }, []); // 依存配列
}
```

#### 依存配列について

- 依存配列に特定の値を指定することで、その値が変更されるたびにuseEffect内の副作用を実行することができます。
- 空の配列`[]`の場合は、初回レンダリング時のみ副作用が実行されます。
 
#### クリーンアップ関数について

- useEffect内で設定した副作用をクリーンアップするための関数になります。これにより、メモリークを防ぎコンポーネントのパフォーマンスの向上させることができます。
- クリーンアップの実行タイミング
  - コンポーネントのマウント時に初回のエフェクト（副作用）が発火されます。クリーンアップ関数は以下のタイミングで実行されます。
    - コンポーネントのアンマウント時。
    - コンポーネントの再レンダリング時。

**[クリーンアップ関数の実装例（タイマーのクリア）]**

```jsx
useEffect(() => {
  const timer = setTimeout(() => {
    console.log('1秒後に実行される');
  }, 1000);
  
  return () => clearTimeout(timer);
}, []);
```

このuseEffectの処理は以下のような機能を持っています。

1. コンポーネントがマウントされたときに、1秒後に実行されるタイマーを設定します。
2. コンポーネントがアンマウントされるときに、クリーンアップ関数が呼ばれて設定されたタイマーをクリアします。

このようにクリーンアップ関数を使用することで、不要なタイマーの実行を防ぎ、メモリリークや予期しない挙動を回避することができます。

👇 クリーンアップ関数についてはこちらの記事がとてもわかりやすかったです。

https://zenn.dev/yumemi_inc/articles/react-effect-simply-explained

👇 詳しくは公式ドキュメントをご覧ください。
https://ja.react.dev/reference/react/useEffect

## 参考情報

https://ja.react.dev/reference/react/useEffect
