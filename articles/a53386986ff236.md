---
title: "useEffectの基本的なアンチパターン"
emoji: "🙅‍♂️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react","javascript"]
published: false
---

## はじめに

今回は、Reactのフックの１つである**useEffect**のアンチパターンについて調べてみようと思った背景としては、現場のプロジェクトでuseEffect警察（フロントつよつよエンジニアさん）に「不要なuseEffectを使用してしまっている」というレビューをいただいたのがきっかけになります。

私はこれまで何となくuseEffectを使いまくることは良くないという認識でいましたが、具体的にどのようなユースケースでuseEffectを使用すると良くないのかまで理解できていなかったため、今回改めて調べてみようと思いました。

:::message
間違っている説明や解釈などありましたら、ご指摘いただけると幸いです。
:::

## useEffectとは

最初にuseEffectの基本について説明します。

useEffectはReactのフックの一つで、副作用を管理するために使用されます。このフックを使用することで、コンポーネントのレンダリング後に特定の関数を実行するタイミングを制御することができます。

:::message
**副作用とは**
コンポーネントのレンダリングプロセスの外部で行われる操作のことを指します。具体的には、データフェッチ・DOM操作・ログの記録などが挙げられます。
:::

### 基本的な実装方法

```jsx
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // 副作用のロジックをここに書きます

    return () => {
      // クリーンアップのロジックをここに書きます
    };
  }, []); // 依存配列
}
```

#### 依存配列について

- 依存配列に特定の値を指定することで、その値が変更されるたびにuseEffect内の副作用を実行することができます。
- 空の配列`[]`の場合は、初回レンダリング時のみ副作用が実行されます。
 
#### クリーンアップ関数について

- useEffect内で設定した副作用をクリーンアップするための関数になります。これにより、メモリークを防ぎコンポーネントのパフォーマンスの向上させることができます。
- クリーンアップの実行タイミング
  - コンポーネントのマウント時に初回のエフェクト（副作用）が発火されます。クリーンアップ関数は以下のタイミングで実行されます。
    - コンポーネントのアンマウント時。
    - コンポーネントの再レンダリング時。

**[クリーンアップ関数の実装例（タイマーのクリア）]**

```jsx
useEffect(() => {
  const timer = setTimeout(() => {
    console.log('1秒後に実行される');
  }, 1000);
  
  return () => clearTimeout(timer);
}, []);
```

このuseEffectの処理は以下のような機能を持っています。

1. コンポーネントがマウントされたときに、1秒後に実行されるタイマーを設定します。
2. コンポーネントがアンマウントされるときに、クリーンアップ関数が呼ばれて設定されたタイマーをクリアします。

このようにクリーンアップ関数を使用することで、不要なタイマーの実行を防ぎ、メモリリークや予期しない挙動を回避することができます。

👇 クリーンアップ関数についてはこちらの記事がとてもわかりやすかったです。

https://zenn.dev/yumemi_inc/articles/react-effect-simply-explained

👇 詳しくは公式ドキュメントをご覧ください。
https://ja.react.dev/reference/react/useEffect

## 不要なuseEffectを使用してしまった実装

次に、私が不要なuseEffectを使用してしまったユースケースについて簡単に説明したいと思います。

- **実装した機能**
  - リスト形式で表示しているデータをセレクトボックスで選択された値でフィルタリングする機能。
  - セレクトボックスで選択した値のidをURLのクエリパラメーターに設定して、設定されたクエリパラメーターを読み取り、そのidをリクエストで送信することで、選択されたデータを取得します。

↓ 画面イメージ

![](https://storage.googleapis.com/zenn-user-upload/28d3a756c0b6-20240702.png)

私はこのユースケースで、子コンポーネントのセレクトボックスに選択した「カテゴリー名」を表示させるために、useEffectを使用してクエリパラメータの値が変更されたら、useEffectの処理を発火させる実装を行なってしまいました。

この実装では、クエリパラメータの値が更新されたタイミングでReactコンポーネントが再レンダリングされるため、useEffectを使用しないでもセレクトボックスに新たに選択した「カテゴリー名」を設定することができます。

そのため、今回の実装でuseEffectを使用してしまうと、不要なレンダリングが発生してしまいます。

**[今回の実装での再レンダリングの流れ]**

```text
1.ユーザーがセレクトボックスでカテゴリーを選択 
↓
2. URLのクエリパラメータの更新 
↓
3. Reactコンポーネントの再レンダリング
↓
4. 現在のカテゴリー名の再計算
```

この「再レンダリングの流れ」により、クエリパラメータが更新されたタイミングで再レンダリングが発生するので、useEffectは不要な実装になっていました。

:::message
**レンダリングとは**
Reactコンポーネントの状態（state）やプロパティ（props）に基づいて、DOMを描画するプロセスのことです。このプロセスには**初回レンダリング**と**再レンダリング**のフェーズがあります。

**初回レンダリング**
ReactDOM.render()により、ReactコンポーネントをブラウザのDOMにマウントします。
コンポーネントのレンダリングにより、関数コンポーネントの戻り値を評価して、仮想DOMを生成します。
その後、仮想DOMと実際のDOMの差分を計算して、必要な部分のみ実際のDOMに反映させます。

**再レンダリング**
stateやpropsの変更に応じてコンポーネントが再評価されるプロセスになります。
変更されたstateやpropsに基づいてrenderメソッドや関数コンポーネントを評価して、新しい仮想DOMを生成します。

:::

Reactコンポーネントの再レンダリングについては以下の記事がすごくわかりやすかったです。

https://zenn.dev/b1essk/articles/react-re-rendering

https://qiita.com/yokoto/items/ee3ed0b3ca905b9016d3

## 基本的なアンチパターン

では、やっとuseEffectの基本的なアンチパターンについてコード例を用いて解説していきます。

## 参考情報

https://ja.react.dev/reference/react/useEffect
